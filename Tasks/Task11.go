package Tasks

// Реализовать пересечение двух неупорядоченных множеств.
import (
	"fmt"
	"math/rand"
	"time"
)

func T11() {
	// Очевидно, что с множествами лучше всего работать в хешмапах, они под это и заточены? длину сделаем максимум из 100
	//Иначе при увеличении количества ключей, может создаваться копия в функциях, исходная функция этих изменений может не отловить,
	//Еще это вылечить можно ссылаясь в функциях на мапу(по указателю), тогда копии и перемещения будут отловлены исх. функцией
	// (Механизм похож на срезы с их длиной и вместимостью)
	rand.Seed(time.Now().Unix())
	temps1 := make(map[int64]struct{}, 100)
	temps2 := make(map[int64]struct{}, 100)
	result := make(map[int64]struct{}, 100)
	// Пустые структуры имеют вес в 0 байт, нам ведь нужны только уникальные значения
	Gennum(temps1, 100)
	Gennum(temps2, 100)
	//Проверяем размеры, если кинуть в проверку бОльшую из хешмап, то может привести к неожиданным последствиям
	if len(temps1) < len(temps2) {
		for i := range temps1 {
			//Проверяем наличие ключа в t2 из t1
			_, ok := temps2[i]
			if ok {
				// Пишу в результат, если нашелся
				result[i] = struct{}{}
			}
		}
	} else {
		for i := range temps2 {
			_, ok := temps1[i]
			if ok {
				result[i] = struct{}{}
			}
		}
	}
	fmt.Println(result)
}

// Заполняем множества рандомными числами
func Gennum(data map[int64]struct{}, rng int) {
	for i := 0; i < rng; i++ {
		data[rand.Int63n(100)] = struct{}{}
	}
}
