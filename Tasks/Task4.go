package Tasks

import (
	"fmt"
	"math/rand"
	"os"
	"os/signal"
	_ "os/signal"
	"syscall"
)

// Реализовать постоянную запись данных в канал (главный поток). Реализовать
// набор из N воркеров, которые читают произвольные данные из канала и выводят
// в stdout. Необходима возможность выбора количества воркеров при старте.
//
// Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать
// способ завершения работы всех воркеров.

// Функция генерации работяг
func generateWorkers(amount int, ch chan int) {
	//Кидаю цикл по количеству работяг, сую каждого в свою горутину, которые выводят данные из канала
	for i := 0; i < amount; i++ {
		go func(i int) {
			for num := range ch {
				fmt.Println(num)
				fmt.Println(i)
			}
		}(i)
	}

}

func T4() {
	var amount int
	fmt.Println("Введите количество работяг")
	//Создаю 2 канала, один для данных, второй для отслеживания прерывания
	fmt.Scanf("%d\n", &amount)
	ch := make(chan int)
	osSignals := make(chan os.Signal, 1)
	//SIGINT отслеживает прерывания, для консоли по дефолту Ctrl+C
	signal.Notify(osSignals, syscall.SIGINT)
	generateWorkers(amount, ch)
	//После того, как словит прерывание, еще не значит, что оно сработает, надо его обработать
loop:
	//Гениальным решением является использование селекта и бесконечного цикла
	for {
		select {
		//Словили команду "Голос" от канала прерывания и дропнули цикл, работа функции пошла дальше
		case <-osSignals:
			close(ch)
			break loop
			// Если команды не было, кидаем в канал данные, пусть с ними работают воркеры
		default:
			ch <- rand.Int()
		}
	}
}
