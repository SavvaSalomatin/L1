package Tasks

// Разработать программу, которая будет последовательно отправлять значения
// в канал, а с другой стороны канала — читать. По истечению N секунд
// программа должна завершаться.
import (
	"fmt"
	"time"
)

func T5() {
	//Инициализируем переменную задержки, которую можно будет по пользовательскому вводу задать
	var dur time.Duration
	fmt.Println("Введите время работы программы в секундах")
	fmt.Scanf("%d\n", &dur)
	i := 0
	//Стандартная работа с каналом
	ch := make(chan int)
	// Один из вариантов - создание отдельной переменной, считающей количество времени по time.Now(), в которую мы кидаем задержку
	//var stop = time.After(dur * time.Second)
	// Отдельной горутиной кидаем в канал данные
	go func() {
		for {
			ch <- i
			i++
			//Для приличия лучше закидывать значения с небольшой задержкой
			//time.Sleep(time.Millisecond)
		}
	}()
	// Считываем с канала отдельной рутиной
	go func() {
		for i := range ch {
			fmt.Println(i)
		}
	}()
	// Второй вариант - "заморозить" работу основной рутины(main) на время, пока порожденные ей работают, при выходе из нее
	// упадут и остальные
	time.Sleep(time.Second * dur)
	// Вернемся к первому варианту, здесь основная рутина ждет, когда ей передадут срабатывание задержки, которую
	// объявили выше
	//<-stop
}
